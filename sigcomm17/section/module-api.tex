\section{NF Module API}

\begin{table}[!b]
\centering
\caption{The public API methods that must be implemented for each NF modules in NFActor framework.}
\label{table:api}
\resizebox{\columnwidth}{!}{
\begin{tabular}{c|l}
\textbf{API}                                      & \multicolumn{1}{c}{\textbf{Usage}}                                                                                                                                                                                                         \\ \hline
nf.allocate\_new\_fs()                            & \begin{tabular}[c]{@{}l@{}}Allocate a new flow state for\\ a new flow actor.\end{tabular}                                                                                                                                                  \\ \hline
nf.deallocate\_fs(fs)                             & \begin{tabular}[c]{@{}l@{}}Deallocate the flow state \\ when the flow actor expires\\ or quits.\end{tabular}                                                                                                                               \\ \hline
nf.process\_pkt(input\_pkt, fs)                   & \begin{tabular}[c]{@{}l@{}}Process the input packet using the \\ current flow state associated with the\\ flow actor.\end{tabular}                                                                                                         \\ \hline
nf.get\_migration\_target(cluster\_cfg, fs) & \begin{tabular}[c]{@{}l@{}}Query the NF using the current\\ cluster configuration and the current\\ flow state about where the flow\\ actor should be migrated to. This\\ method enables each actor to do\\ active migration.\end{tabular} \\ \hline
\end{tabular}
}
\end{table}

To facilitate transparent resilience, NFActor framework needs to ensure a clean separation between the NF processing logic and the flow states associated with each flow. To enforce this criteria, we build a set of easy to use APIs that can be used to create a broad range of NF modules for NFActor framework. Programmers using these APIs could focus on the design of internal NF logic and the created NF modules could be transparently integrated with the resilient flow management tasks.

Table \ref{table:api} summarizes these APIs, which are provided as four public methods for each NF module. The first two methods are used by each flow actor to acquire and release flow state from a NF module. To achieve transparent resilience, the flow actor must be able to extract and transmit the flow states of all the NF modules on the service chain, without disturbing the service chain processing. Therefore, NFActor framework provides explicit flow state allocation/deallocation method for each flow actor to use, which are shown as the first 2 methods in table \ref{table:api}. By implementing these two methods, flow actor could save the flow state as its internal state and transparently transmit the flow state during both flow migration and replication.

The third method is where the actual NF processing logic is implemented. The flow actor calls this method by passing in the input packet along with the flow state. When the third method returns, the flow actor saves the updated flow state and send the input packet to the output port. The combination of the first three methods separate the flow state with the core NF processing logic. When combining with actor execution, it ensures transparent resilience.

The flow actor could use the fourth method to check where the NF would like the actor to migrate to, by passing the current cluster configuration and the current flow state. This enables the flow actor to actively migrate itself instead of waiting for migration initiation command sends from the controller \ref{}, and sparkles several useful applications (i.e. decreasing the output bandwidth during deduplication and ensuring reliable MPTCP subflow processing \ref{}) that none of existing NFV systems can achieve.
